from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import requests
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
import re
import os
import warnings

warnings.filterwarnings('ignore')

app = Flask(__name__)
CORS(app)


class VulnerabilityScanner:
    def __init__(self, target_url, timeout=10):
        self.target_url = target_url
        self.timeout = timeout
        self.session = requests.Session()
        self.vulnerabilities = []
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
        }

    def scan(self):
        """Run all vulnerability scans"""
        try:
            self.check_ssl_certificate()
            self.check_security_headers()
            self.check_cookie_security()
            self.check_cors_policy()
            self.check_outdated_libraries()
            self.check_sql_injection()
            self.check_xss_vulnerabilities()
            self.check_directory_traversal()
            self.check_sensitive_files()
            self.check_open_redirects()
            self.check_information_disclosure()
            self.check_http_methods()
        except Exception as e:
            
            self.log_finding("Scan Error", str(e), "Info",
                             evidence="Exception during full scan", vuln_desc="", risk_desc="", recommendation="")
        return self.generate_report()

    def check_ssl_certificate(self):
        """Check SSL/TLS certificate validity"""
        try:
            if self.target_url.startswith('https'):
                
                try:
                    self.session.head(self.target_url, verify=True, timeout=self.timeout, headers=self.headers)
                    self.log_finding(
                        "âœ“ SSL Certificate",
                        "Valid SSL certificate detected",
                        "Info",
                        evidence="HTTPS connection established successfully",
                        vuln_desc="The website uses HTTPS protocol with a valid SSL/TLS certificate.",
                        risk_desc="No risk - the connection is secure and encrypted.",
                        recommendation="Continue maintaining valid SSL certificates and renew before expiration."
                    )
                except requests.exceptions.SSLError as e:
                    self.log_finding(
                        "âœ— SSL Certificate",
                        "Invalid or expired SSL certificate",
                        "High",
                        evidence=f"SSL Error: {str(e)[:200]}",
                        vuln_desc="The SSL/TLS certificate is either expired, self-signed, or issued by an untrusted Certificate Authority.",
                        risk_desc="Users will see security warnings in their browsers. Attackers could exploit this to perform MITM attacks.",
                        recommendation="Renew or replace the SSL certificate immediately. Use trusted CAs and ensure proper certificate chain."
                    )
            else:
                self.log_finding(
                    "âœ— No HTTPS",
                    "Website does not use HTTPS encryption",
                    "High",
                    evidence=f"Connection established via HTTP: {self.target_url}",
                    vuln_desc="The website is accessible via HTTP protocol without SSL/TLS encryption.",
                    risk_desc="Attackers can intercept and read sensitive information (passwords, personal data, session tokens).",
                    recommendation="Implement HTTPS immediately. Obtain an SSL/TLS certificate (Let's Encrypt is free). Configure redirects and HSTS."
                )
        except Exception as e:
            
            self.log_finding("SSL Check Error", str(e), "Info")

    def check_cookie_security(self):
        """Check for insecure cookie configurations by examining Set-Cookie headers"""
        try:
            resp = self.session.get(self.target_url, headers=self.headers, timeout=self.timeout, verify=False)
            set_cookie_header = resp.headers.get('Set-Cookie', '')
            if not set_cookie_header:
                
                self.log_finding(
                    "âœ“ Cookie Check",
                    "No Set-Cookie headers found on root response",
                    "Info",
                    evidence="No Set-Cookie header present",
                    vuln_desc="No cookies found on the main response.",
                    risk_desc="No cookie-related risk on root response.",
                    recommendation="Check other endpoints that create sessions or auth cookies."
                )
                return

            
            cookies = re.split(r', (?=[^;]+=[^;]+;?)', set_cookie_header)
            insecure_cookies = []

            for cookie_str in cookies:
                issues = []
                if 'secure' not in cookie_str.lower():
                    issues.append("missing Secure flag")
                if 'httponly' not in cookie_str.lower():
                    issues.append("missing HttpOnly flag")
                if 'samesite' not in cookie_str.lower():
                    issues.append("missing SameSite attribute")

                
                name_match = re.match(r'\s*([^=;\s]+)=', cookie_str)
                cookie_name = name_match.group(1) if name_match else "<unknown>"
                if issues:
                    insecure_cookies.append(f"{cookie_name}: {', '.join(issues)}")

            if insecure_cookies:
                self.log_finding(
                    "âœ— Insecure Cookie Configuration",
                    f"Found {len(insecure_cookies)} cookie(s) with security issues",
                    "High",
                    evidence="\n".join(insecure_cookies),
                    vuln_desc="Cookies are configured without proper security flags.",
                    risk_desc="Session hijacking or CSRF possible if cookies are insecure.",
                    recommendation="Set Secure, HttpOnly, and SameSite attributes for cookies. Example: Set-Cookie: sessionid=abc; Secure; HttpOnly; SameSite=Strict"
                )
            else:
                self.log_finding(
                    "âœ“ Cookie Security",
                    "Cookies appear to have security flags",
                    "Info",
                    evidence="Set-Cookie header includes Secure, HttpOnly and SameSite attributes",
                    vuln_desc="Cookies configured with standard security attributes.",
                    risk_desc="No immediate cookie security risk.",
                    recommendation="Continue monitoring cookie configuration."
                )
        except Exception as e:
            self.log_finding("Cookie Check Error", str(e), "Info")

    def check_cors_policy(self):
        """Check CORS policy configuration"""
        try:
            headers_with_origin = self.headers.copy()
            headers_with_origin['Origin'] = 'https://evil.com'
            resp = self.session.get(self.target_url, headers=headers_with_origin, timeout=self.timeout, verify=False)

            acao = resp.headers.get('Access-Control-Allow-Origin', '')
            acac = resp.headers.get('Access-Control-Allow-Credentials', '')

            if acao == '*' and acac.lower() == 'true':
                self.log_finding(
                    "âœ— Insecure CORS Configuration",
                    "CORS policy allows any origin with credentials",
                    "High",
                    evidence=f"Access-Control-Allow-Origin: {acao}\nAccess-Control-Allow-Credentials: {acac}",
                    vuln_desc="The CORS policy is configured to allow requests from any origin (*) while also allowing credentials.",
                    risk_desc="Attackers can make authenticated requests from malicious websites to steal data.",
                    recommendation="Do not use Access-Control-Allow-Origin: * with credentials. Use an allowlist of origins and validate Origin header."
                )
            elif acao and acao == headers_with_origin['Origin']:
                self.log_finding(
                    "âœ— CORS Misconfiguration",
                    "CORS policy reflects arbitrary origins",
                    "Medium",
                    evidence=f"Requested Origin: {headers_with_origin['Origin']}\nReflected: {acao}",
                    vuln_desc="CORS reflects the Origin header without validation.",
                    risk_desc="This can allow attackers to bypass same-origin restrictions.",
                    recommendation="Validate origin against a whitelist and do not reflect arbitrary origins."
                )
            elif acao:
                self.log_finding(
                    "âœ“ CORS Policy Present",
                    f"CORS configured with origin: {acao}",
                    "Info",
                    evidence=f"Access-Control-Allow-Origin: {acao}",
                    vuln_desc="CORS header present and not obviously misconfigured.",
                    risk_desc="No immediate issue detected.",
                    recommendation="Review allowed origins for appropriateness."
                )
            else:
                self.log_finding(
                    "âœ“ CORS Policy Not Present",
                    "No Access-Control-Allow-Origin header found",
                    "Info",
                    evidence="No CORS header in response",
                    vuln_desc="No CORS policy header present on main page.",
                    risk_desc="Not necessarily a vulnerability; depends on app design.",
                    recommendation="If cross-origin requests are required, serve a restrictive allowlist."
                )
        except Exception as e:
            self.log_finding("CORS Check Error", str(e), "Info")

    def check_information_disclosure(self):
        """Check for information disclosure"""
        try:
            resp = self.session.get(self.target_url, headers=self.headers, timeout=self.timeout, verify=False)
            disclosures = []
            evidence_parts = []

            server = resp.headers.get('Server', '')
            if server:
                disclosures.append(f"Server: {server}")
                evidence_parts.append(f"HTTP Header Disclosure:\nServer: {server}\nRisk: Reveals web server type/version")

            powered_by = resp.headers.get('X-Powered-By', '')
            if powered_by:
                disclosures.append(f"X-Powered-By: {powered_by}")
                evidence_parts.append(f"HTTP Header Disclosure:\nX-Powered-By: {powered_by}\nRisk: Reveals backend tech")

            content = resp.text
            version_patterns = [
                (r'php/\d+\.\d+', 'PHP version'),
                (r'apache/\d+\.\d+', 'Apache version'),
                (r'nginx/\d+\.\d+', 'Nginx version')
            ]
            for pattern, desc in version_patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    disclosures.append(f"{desc} in content")
                    evidence_parts.append(f"Content Disclosure: Pattern Found: {matches[0]} ({desc})")

            # check for verbose error messages
            error_patterns = ['error', 'exception', 'stack trace', 'warning', 'fatal']
            lines = content.splitlines()
            for i, line in enumerate(lines):
                l = line.lower()
                if any(pat in l for pat in error_patterns):
                    if 'line' in l or 'file' in l or 'trace' in l:
                        context_start = max(0, i - 2)
                        context_end = min(len(lines), i + 3)
                        error_context = "\n".join(lines[context_start:context_end])
                        disclosures.append("Detailed error messages")
                        evidence_parts.append(f"Error Message in Response:\n{error_context}\nRisk: Exposes internal paths/code.")
                        break

            if disclosures:
                full_evidence = "Information Disclosure Analysis:\n\n" + "\n\n".join(evidence_parts)
                self.log_finding(
                    "âœ— Information Disclosure",
                    f"Server information disclosed: {len(disclosures)} issue(s)",
                    "Low",
                    evidence=full_evidence,
                    vuln_desc="Application discloses info about tech stack or errors.",
                    risk_desc="Helps attackers perform reconnaissance.",
                    recommendation="Remove revealing headers, disable debug, and customize error pages."
                )
            else:
                evidence_code = "Information Disclosure Check:\nâœ“ No obvious disclosures detected"
                self.log_finding(
                    "âœ“ Information Disclosure Check",
                    "No obvious information disclosure detected",
                    "Info",
                    evidence=evidence_code,
                    vuln_desc="No significant info disclosed.",
                    risk_desc="No immediate issue.",
                    recommendation="Keep error messages and headers minimal in production."
                )
        except Exception as e:
            self.log_finding("Info Disclosure Check Error", str(e), "Info")

    def check_http_methods(self):
        """Check for dangerous HTTP methods"""
        try:
            dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT']
            allowed_dangerous = []

            for method in dangerous_methods:
                try:
                    resp = self.session.request(method, self.target_url, timeout=self.timeout, verify=False)
                    if resp.status_code not in [405, 501]:
                        allowed_dangerous.append(f"{method} (Status: {resp.status_code})")
                except requests.RequestException:
                    
                    continue

            if allowed_dangerous:
                self.log_finding(
                    "âœ— Dangerous HTTP Methods Allowed",
                    f"Methods allowed: {', '.join(allowed_dangerous)}",
                    "Medium",
                    evidence="\n".join(allowed_dangerous),
                    vuln_desc="The web server allows potentially dangerous HTTP methods.",
                    risk_desc="PUT/DELETE may allow file upload/delete; TRACE may facilitate XST attacks.",
                    recommendation="Disable unnecessary methods and return 405 for them. Restrict to GET/POST/HEAD."
                )
            else:
                self.log_finding(
                    "âœ“ HTTP Methods Check",
                    "Only safe HTTP methods allowed",
                    "Info",
                    evidence="Tested PUT, DELETE, TRACE, CONNECT - all properly restricted",
                    vuln_desc="Web server restricts dangerous HTTP methods.",
                    risk_desc="No issue detected from HTTP methods.",
                    recommendation="Continue restricting methods to only those required."
                )
        except Exception as e:
            self.log_finding("HTTP Methods Check Error", str(e), "Info")

    def check_security_headers(self):
        """Check for missing security headers"""
        try:
            resp = self.session.head(self.target_url, headers=self.headers, timeout=self.timeout, verify=False)
            headers_to_check = {
                'Strict-Transport-Security': {
                    'name': 'HSTS',
                    'vuln_desc': 'HSTS header is missing.',
                    'risk_desc': 'Without HSTS, users may be downgraded to HTTP.',
                    'recommendation': 'Add: Strict-Transport-Security: max-age=31536000; includeSubDomains; preload'
                },
                'X-Frame-Options': {
                    'name': 'Clickjacking Protection',
                    'vuln_desc': 'X-Frame-Options header is missing.',
                    'risk_desc': 'Attackers can embed your site in iframes (clickjacking).',
                    'recommendation': 'Add: X-Frame-Options: DENY or SAMEORIGIN'
                },
                'X-Content-Type-Options': {
                    'name': 'MIME Type Sniffing Protection',
                    'vuln_desc': 'X-Content-Type-Options header is missing.',
                    'risk_desc': 'Browsers might interpret files as different types than intended.',
                    'recommendation': 'Add: X-Content-Type-Options: nosniff'
                },
                'Content-Security-Policy': {
                    'name': 'Content Security Policy',
                    'vuln_desc': 'CSP header is missing.',
                    'risk_desc': 'Without CSP, XSS mitigation is weaker.',
                    'recommendation': "Start with: Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'"
                },
                'X-XSS-Protection': {
                    'name': 'XSS Protection Header',
                    'vuln_desc': 'X-XSS-Protection header missing or disabled.',
                    'risk_desc': 'Deprecated but helpful in older browsers.',
                    'recommendation': 'Add: X-XSS-Protection: 1; mode=block'
                }
            }

            all_headers = "\n".join([f"{k}: {v}" for k, v in resp.headers.items()])

            for header, details in headers_to_check.items():
                if header not in resp.headers:
                    evidence_code = f"HTTP Response Headers:\n{all_headers}\n\nMissing Header: {header}\n\nExpected: {details['recommendation']}"
                    self.log_finding(
                        f"âœ— Missing {header}",
                        f"Missing {details['name']} header",
                        "Medium",
                        evidence=evidence_code,
                        vuln_desc=details['vuln_desc'],
                        risk_desc=details['risk_desc'],
                        recommendation=details['recommendation']
                    )
                else:
                    self.log_finding(
                        f"âœ“ {header}",
                        f"{details['name']} header present: {resp.headers[header]}",
                        "Info",
                        evidence=f"{header}: {resp.headers[header]}",
                        vuln_desc=f"The {details['name']} security header is properly configured.",
                        risk_desc="No risk - header present.",
                        recommendation="Continue to maintain this header."
                    )
        except Exception as e:
            self.log_finding("Security Headers Check Error", str(e), "Info")

    def check_outdated_libraries(self):
        """Check for common outdated libraries in responses"""
        try:
            resp = self.session.get(self.target_url, headers=self.headers, timeout=self.timeout, verify=False)
            content = resp.text.lower()

            outdated_libs = {
                'jquery 1.': {
                    'name': 'jQuery 1.x',
                    'vuln': 'jQuery 1.x detected - has known XSS vulnerabilities.',
                    'rec': 'Upgrade to jQuery 3.x or later.'
                },
                'jquery-1.': {
                    'name': 'jQuery 1.x',
                    'vuln': 'jQuery 1.x detected.',
                    'rec': 'Upgrade to jQuery 3.x or later.'
                },
                'bootstrap 2': {
                    'name': 'Bootstrap 2.x',
                    'vuln': 'Bootstrap 2.x detected - outdated.',
                    'rec': 'Upgrade to Bootstrap 4/5.'
                },
                'angular 1.': {
                    'name': 'AngularJS 1.x',
                    'vuln': 'AngularJS 1.x detected - end-of-life.',
                    'rec': 'Migrate to modern framework or Angular 2+.'
                }
            }

            found_any = False
            for pattern, details in outdated_libs.items():
                if pattern in content:
                    found_any = True
                    self.log_finding(
                        f"âœ— Outdated Library: {details['name']}",
                        details['vuln'],
                        "Medium",
                        evidence=f"Pattern '{pattern}' found in page source excerpt",
                        vuln_desc=details['vuln'],
                        risk_desc="Using unmaintained frontend libs increases attack surface.",
                        recommendation=details['rec']
                    )

            if not found_any:
                self.log_finding(
                    "âœ“ Library Version Check",
                    "No obviously outdated libraries detected",
                    "Info",
                    evidence="Scanned page source for common outdated frontend libraries; none detected",
                    vuln_desc="No outdated libraries detected in initial scan.",
                    risk_desc="No immediate risk.",
                    recommendation="Keep libraries updated and use dependency scanners."
                )
        except Exception as e:
            self.log_finding("Outdated Libraries Check Error", str(e), "Info")

    def check_sql_injection(self):
        """Check for SQL injection vulnerabilities (basic heuristic checks)"""
        payloads = ["' OR '1'='1", "1' UNION SELECT NULL--", "admin'--"]
        try:
            sql_errors = ['sql', 'mysql_fetch', 'warning: mysql', 'sql syntax', 'sqlexception', 'sql error']

            for payload in payloads:
                test_url = f"{self.target_url}?id={requests.utils.requote_uri(payload)}"
                try:
                    resp = self.session.get(test_url, timeout=self.timeout, verify=False)
                    for error in sql_errors:
                        if error in resp.text.lower():
                           
                            lines = resp.text.splitlines()
                            for i, line in enumerate(lines):
                                if error in line.lower():
                                    start = max(0, i - 2)
                                    end = min(len(lines), i + 3)
                                    snippet = "\n".join(lines[start:end])
                                    evidence_code = f"GET {test_url}\n\nServer Response Extract:\n{snippet}"
                                    self.log_finding(
                                        "âœ— SQL Injection Detected",
                                        "Potential SQL injection vulnerability found",
                                        "Critical",
                                        evidence=evidence_code,
                                        vuln_desc="User input appears to be included in SQL error output.",
                                        risk_desc="Attackers could extract or modify database contents.",
                                        recommendation="Use parameterized queries, input validation, and ORM protections."
                                    )
                                    return
                except requests.RequestException:
                    continue

            
            evidence_code = f"Tested SQL Injection Payloads against {self.target_url}?id=[payload]\nResult: No SQL error messages detected"
            self.log_finding(
                "âœ“ SQL Injection Check",
                "No obvious SQL injection detected",
                "Info",
                evidence=evidence_code,
                vuln_desc="No SQL injection found during basic checks.",
                risk_desc="Does not guarantee absence of SQLiâ€”manual testing and code review recommended.",
                recommendation="Use prepared statements and validate input server-side."
            )
        except Exception as e:
            self.log_finding("SQL Injection Check Error", str(e), "Info")

    def check_xss_vulnerabilities(self):
        """Check for reflected XSS vulnerabilities (basic checks)"""
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert(1)</script>',
            '<img src=x onerror=alert("XSS")>'
        ]
        try:
            test_url_base = self.target_url + ("&" if "?" in self.target_url else "?") + "xss="
            for payload in xss_payloads:
                test_url = test_url_base + requests.utils.requote_uri(payload)
                try:
                    resp = self.session.get(test_url, timeout=self.timeout, verify=False)
                    if payload in resp.text:
                        
                        lines = resp.text.splitlines()
                        reflected_lines = []
                        for i, line in enumerate(lines):
                            if payload in line:
                                start = max(0, i - 2)
                                end = min(len(lines), i + 3)
                                context = lines[start:end]
                                highlighted = "\n".join([f">>> {l.strip()}" if payload in l else f"    {l.strip()}" for l in context])
                                evidence_code = f"GET {test_url}\n\nResponse HTML Code:\n{highlighted}"
                                self.log_finding(
                                    "âœ— XSS Vulnerability",
                                    "Potential reflected XSS vulnerability detected",
                                    "High",
                                    evidence=evidence_code,
                                    vuln_desc="User input reflected without proper encoding.",
                                    risk_desc="Attacker can execute scripts in victim's browser.",
                                    recommendation="Encode output, use CSP, validate input on server-side."
                                )
                                return
                except requests.RequestException:
                    continue

            self.log_finding(
                "âœ“ XSS Check",
                "No obvious reflected XSS detected",
                "Info",
                evidence=f"Tested common payloads against {self.target_url}?xss=[payload] - none were reflected raw",
                vuln_desc="No immediate reflected XSS found by automated tests.",
                risk_desc="DOM-based and stored XSS require manual testing.",
                recommendation="Implement CSP and output encoding; perform manual tests."
            )
        except Exception as e:
            self.log_finding("XSS Check Error", str(e), "Info")

    def check_directory_traversal(self):
        """Check for directory traversal vulnerabilities"""
        paths = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\win.ini',
        ]
        try:
            for path in paths:
                test_url = urljoin(self.target_url + '/', path)
                try:
                    resp = self.session.get(test_url, timeout=self.timeout, verify=False)
                    text = resp.text.lower()
                    if 'root:' in text or 'administrator' in text or '[fonts]' in text:
                        self.log_finding(
                            "âœ— Directory Traversal",
                            "Potential directory traversal vulnerability detected",
                            "Critical",
                            evidence=f"Path tested: {path}\nURL: {test_url}\nDetected content snippet",
                            vuln_desc="The application may allow traversal to read system files.",
                            risk_desc="Attacker can read sensitive files and system data.",
                            recommendation="Sanitize file path inputs, whitelist files, and restrict file access."
                        )
                        return
                except requests.RequestException:
                    continue

            self.log_finding(
                "âœ“ Directory Traversal Check",
                "No obvious traversal detected",
                "Info",
                evidence="Tested common directory traversal payloads with no positive indicators",
                vuln_desc="No directory traversal found in automated tests.",
                risk_desc="Continue to validate file inputs and use secure APIs.",
                recommendation="Don't trust user-supplied file paths."
            )
        except Exception as e:
            self.log_finding("Directory Traversal Check Error", str(e), "Info")

    def check_sensitive_files(self):
        """Check for common sensitive files"""
        sensitive_files = [
            'robots.txt', '.env', '.git/config', 'web.config',
            'config.php', 'wp-config.php', 'settings.py', '.htaccess'
        ]
        try:
            found_files = []
            file_details = []

            for file in sensitive_files:
                test_url = urljoin(self.target_url + '/', file)
                try:
                    resp = self.session.get(test_url, timeout=self.timeout, verify=False)
                    if resp.status_code == 200:
                        found_files.append(file)
                        content_preview = "\n".join(resp.text.splitlines()[:10])
                        if len(resp.text.splitlines()) > 10:
                            content_preview += "\n... (truncated)"
                        file_details.append(f"File: {file}\nURL: {test_url}\nStatus: {resp.status_code}\nPreview:\n{content_preview}\n{'='*40}\n")
                except requests.RequestException:
                    continue

            if found_files:
                evidence_code = f"Sensitive Files Discovered: {', '.join(found_files)}\n\nDetails:\n{''.join(file_details)}"
                self.log_finding(
                    "âœ— Sensitive Files Exposed",
                    f"Found exposed files: {', '.join(found_files)}",
                    "High",
                    evidence=evidence_code,
                    vuln_desc="Sensitive configuration files are publicly accessible.",
                    risk_desc="Attackers can gather credentials and internal config.",
                    recommendation="Restrict or remove these files from public access; fix server config."
                )
            else:
                self.log_finding(
                    "âœ“ Sensitive Files Check",
                    "No exposed sensitive files detected",
                    "Info",
                    evidence=f"Tested files: {', '.join(sensitive_files)}. None returned 200.",
                    vuln_desc="Common sensitive files not publicly accessible.",
                    risk_desc="No immediate risk identified.",
                    recommendation="Continue to audit file exposure regularly."
                )
        except Exception as e:
            self.log_finding("Sensitive Files Check Error", str(e), "Info")

    def check_open_redirects(self):
        """Check for open redirect vulnerabilities"""
        try:
            redirect_payloads = ['http://evil.com', 'https://attacker.com', '//malicious.com']

            for payload in redirect_payloads:
                test_url = f"{self.target_url}{'&' if '?' in self.target_url else '?'}redirect={requests.utils.requote_uri(payload)}"
                try:
                    resp = self.session.get(test_url, timeout=self.timeout, verify=False, allow_redirects=False)
                    if resp.status_code in [301, 302, 303, 307, 308]:
                        location = resp.headers.get('Location', '')
                        if payload in location or 'evil.com' in location or 'attacker.com' in location or 'malicious.com' in location:
                            self.log_finding(
                                "âœ— Open Redirect",
                                "Potential open redirect vulnerability detected",
                                "Medium",
                                evidence=f"Test URL: {test_url}\nRedirect Status: {resp.status_code}\nLocation Header: {location}",
                                vuln_desc="Application accepts user-controlled redirect destinations without validation.",
                                risk_desc="Used in phishing campaigns to make malicious links look legitimate.",
                                recommendation="Use a whitelist of allowed redirect targets or encode internal reference IDs instead of URLs."
                            )
                            return
                except requests.RequestException:
                    continue

            self.log_finding(
                "âœ“ Open Redirect Check",
                "No obvious open redirects detected",
                "Info",
                evidence="Tested redirect parameters with malicious domains - no unvalidated redirects found",
                vuln_desc="No open redirect vulnerabilities detected in automated testing.",
                risk_desc="No immediate open redirect risk identified.",
                recommendation="Validate redirect destinations and use whitelists."
            )
        except Exception as e:
            self.log_finding("Open Redirect Check Error", str(e), "Info")

    def log_finding(self, title, description, severity, evidence="", vuln_desc="", risk_desc="", recommendation=""):
        """Log a vulnerability finding"""
        self.vulnerabilities.append({
            'title': title,
            'description': description,
            'severity': severity,
            'evidence': evidence,
            'vulnerability_description': vuln_desc,
            'risk_description': risk_desc,
            'recommendation': recommendation
        })

    def generate_report(self):
        """Generate scan report"""
        report = {
            'target': self.target_url,
            'domain': urlparse(self.target_url).netloc,
            'total_issues': len(self.vulnerabilities),
            'vulnerabilities': self.vulnerabilities,
            'severity_breakdown': {
                'Critical': len([v for v in self.vulnerabilities if v['severity'] == 'Critical']),
                'High': len([v for v in self.vulnerabilities if v['severity'] == 'High']),
                'Medium': len([v for v in self.vulnerabilities if v['severity'] == 'Medium']),
                'Low': len([v for v in self.vulnerabilities if v['severity'] == 'Low']),
                'Info': len([v for v in self.vulnerabilities if v['severity'] == 'Info'])
            }
        }
        return report



@app.route('/')
def home():
    """Serve the main HTML page if exists in ../frontend/index.html"""
    try:
        frontend_path = os.path.join(os.path.dirname(__file__), '..', 'frontend', 'index.html')
        if os.path.exists(frontend_path):
            return send_file(frontend_path)
        else:
            return jsonify({
                'message': 'Vulnerability Scanner Backend is running. Frontend file not found.'
            }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/scan', methods=['POST'])
def scan_website():
    """API endpoint to scan a website for vulnerabilities"""
    try:
        data = request.get_json(force=True)
        target_url = data.get('url', '').strip()

        if not target_url:
            return jsonify({'error': 'URL is required'}), 400

        
        if not target_url.startswith(('http://', 'https://')):
            target_url = 'https://' + target_url

        
        parsed = urlparse(target_url)
        if not parsed.scheme or not parsed.netloc:
            return jsonify({'error': 'Invalid URL format'}), 400

        
        scanner = VulnerabilityScanner(target_url)
        report = scanner.scan()

        return jsonify({
            'success': True,
            'report': report
        }), 200

    except Exception as e:
        return jsonify({
            'error': str(e),
            'success': False
        }), 500


@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'message': 'Vulnerability Scanner Backend is running'
    }), 200


if __name__ == '__main__':
    print("=" * 60)
    print("ðŸ”’ Web Vulnerability Scanner Backend")
    print("=" * 60)
    print("âœ“ Backend is starting...")
    print("âœ“ Open your browser and go to: http://127.0.0.1:5000")
    print("âœ“ Press CTRL+C to quit")
    print("=" * 60)
    
    app.run(debug=True, host='0.0.0.0', port=5000)
